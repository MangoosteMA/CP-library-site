\title[]{Дп на деревьях}

\details[mode=main; summary=Введение] {
    Здесь речь пойдёт не о самих динамиках на деревьях, а о их времени работы. Мы рассмотрим классическую модель:
    
    \itemize[] {
        \item[] {
            Для каждой вершины хранится динамика определённого размера.
        }
        \item[] {
            Для пересчёта динамики в вершине, постепенно перебираются дети и их значения динамики сливаются с текущими.
        }
    }
}

\center[] {<h2>$n \times \mathrm{size}_v$</h2>}

\details[mode=main; summary=Введение] {
    Рассмотрим такую модель:
    
    \itemize[] {
        \item[] {
            В каждой вершине dp инициализируется за \complexity$(1)$.
        }
        \item[] {
            При добавлении очередного сына, пусть размер его динамики равен $a$, а размер текущей динамики в вершине равен $b$. Тогда слияние происходит за \complexity$(ab)$, а размер новой динамики в вершине становится равным $a + b$.
        }
    }
    
    Таким образом, после слияния всех детей, размер динамики в вершине $v$ равен \complexity$(\mathrm{size}_v)$.
}

\details[mode=main; summary=Время работы] {
    Время работы такой динамики составляет \complexity$(n^2)$. Более того, на любом дереве, такая динамика в наивной реализации делает не меньше \complexity$(n^2)$ операций, поэтому эта оценка точная.
    
    Давайте каждому значению динамики вершины $v$ сопоставим какую-то вершину из поддерева вершины $v$. При инициализации динамики, всем значениям сопоставим саму вершину $v$. Тогда слияние двух динамик работает за столько же, за сколько перебор всех пар вершин, где первая вершина в паре сопоставлена какому-то значению первой динамики, а вторая~--- значению второй динамики. Значениям новой динамики, назначим по одной вершине из вершин этих динамик (так как размер новой динамики как раз равен сумме размеров этих динамик).
    
    Нетрудно видеть, что каждая пара вершин переберётся при таких слияниях ровно один раз, так как в самом конце все вершины сопоставлены одной динамике и после перебора какой-то пары вершин, они сопоставляются одной и той же динамике, поэтому далее они не будут учтены.
}

\details[mode=main; summary=Задачи] {
    \item[] {\link[href=https://atcoder.jp/contests/abc207/tasks/abc207_f]{Atcoder ABC207-F}}
    \item[] {\link[href=https://atcoder.jp/contests/agc001/tasks/agc001_c]{Atcoder AGC001-C}}
    \item[] {\link[href=https://atcoder.jp/contests/arc121/tasks/arc121_e]{Atcoder ARC121-E}}
    \item[] {\link[href=https://atcoder.jp/contests/arc130/tasks/arc130_d]{Atcoder ARC130-D}}
    \item[] {\link[href=https://atcoder.jp/contests/arc171/tasks/arc171_c]{Atcoder ARC171-C}}
}

\center[] {<h2>$n \times \min(k, \mathrm{size}_v)$  </h2>}

\details[mode=main; summary=Введение] {
    Дано число $k$. Рассмотрим такую модель:
    
    \itemize[] {
        \item[] {
            В каждой вершине dp инициализируется за \complexity$(1)$.
        }
        \item[] {
            При добавлении очередного сына, пусть размер его динамики равен $a$, а размер текущей динамики в вершине равен $b$. Тогда слияние происходит за \complexity$(ab)$, а размер новой динамики в вершине становится равным $\min(k, a + b)$.
        }
    }
}

\details[mode=main; summary=Время работы] {
    Тривиальной оценкой будет \complexity$(nk^2)$, так как каждое слиение работает не хуже чем за \complexity$(k^2)$, а количество слияний равно количеству рёбер, то есть их линейно. Но эта оценка не очень хорошая. Мы докажем, что такая динамика работает за \complexity$(nk)$.
    
    Рассмотрим несколько случаев и для каждого из них покажем эту оценку:
    
    \itemize[] {
        \item[] {
            В момент слияния оба размера были $< k$.
            
            \details[summary=Доказательство] {
                Давайте рассмотрим все вершины $v_1$, $\ldots$, $v_m$, что размер их поддерева меньше $k$, а размер поддерева их предка уже $\ge k$. Такие слияния происходят только внутри поддеревьев этих вершин.
                
                Размер динамики для таких вершин равен размеру их поддерева. Для ттакого вида динамики время работы квадратично зависит от размеров поддеревьев этих вершин (это было доказано ранее). А значит время работы таких слияний не превосходит:
                $$
                \sum\limits_{t=1}^m \mathrm{size_{v_t}}^2
                $$
                Но так как $\sum\limits_{t=1}^m size_v \le n$ эту сумму можно оценить сверху, как $nk$. Это несложный математических факт, следующий из неравенства о средних.\qed
            }
        }
        \item[] {
            В момент слияния размер одной из динамик был $< k$, а другой $= k$.
            
            \details[summary=Доказательство] {
                Рассмотрим вершины $v_1$, $\ldots$, $v_m$ из предыдущего доказательства. Заметим, что такой тип слияний может происходить только с ними и их предками. Значит время работы таких слияний можно оценить сверху следующим образом:
                $$
                \sum\limits_{t=1}^m k \cdot \mathrm{size_{v_t}} \le nk
                $$
                Это завершает доказательство этого случая.\qed
            }
        }
        \item[] {
            В момент слияния размер обоих динамик $=k$.

            \details[summary=Доказательство] {
                Давайте каждому из $k$ значений динамики будем сопоставлять какую-то вершину из поддерева. При инициализации динамики в вершине $v$, сопоставим всем значениям саму вершину $v$. При слиянии таких динамик, новой динамике сопоставим вершины из первой динамики. Тогда при каждом таком слиянии, $k$ вершин, которые были сопоставлены второй динамике далее не будут использованы.
                
                Таким образом, количество таких слияний не превосходит $\frac{n}{k}$, поэтому время работы таких слияний можно оценить, как \complexity$(k^2 \cdot \frac{n}{k}) = $ \complexity$(nk)$.\qed
            }
        }
    }
}

\details[mode=main; summary=Замечание] {
    Можно показать, что на любом дереве данная динамика в наивной реализации работает не лучше чем за \complexity$(n \min(n, k))$.
}

\details[mode=main; summary=Задачи] {
    \item[] {\link[href=https://atcoder.jp/contests/abc235/tasks/abc235_h]{Atcoder ABC235-Ex}}
    \item[] {\link[href=https://contest.ucup.ac/contest/1472/problem/7895]{The 2nd Universal Cup. Stage 17: Jinan. Задача B.}}
}

\center[] {<h2>Переливания по размерам</h2>}

\details[mode=main; summary=Введение] {
    Рассмотрим такую модель:
    
    \itemize[] {
        \item[] {
            В каждой вершине dp инициализируется за \complexity$(1)$.
        }
        \item[] {
            При добавлении очередного сына, пусть размер его динамики равен $a$, а размер текущей динамики в вершине равен $b$. Тогда слияние происходит за \complexity$(\min(a, b))$, а размер новой динамики в вершине становится равным $a + b$.
        }
    }
    
    Таким образом, размер динамики вершины $v$ равен \complexity$(\mathrm{size}_v)$.
}

\details[mode=main; summary=Время работы] {
    Слияние за \complexity$(\min(a, b))$ можно воспринимать, как перебор всех элементов меньшей из динамик. Но заметем, что для каждого из элементов меньшей из динамик, размер новой динамики, которой они будут принадлежать хотя бы в два раза больше, чем размер предыдущей динамики, так как $a + b \ge 2 \min(a, b)$. Размер итоговой динамики линеен, поэтому каждый элемент может быть перебран максимум \complexity$(\log n)$ раз.
    
    Таким образом, такая динамика работает за \complexity$(n\log n)$.
}

\details[mode=main; summary=Замечание] {
    \item[] {Если бы слияние двух динамик происходило за \complexity$(a \log (a + b))$, то алгоритм работал бы за \complexity$(n\log^2 n)$, так как $\log(a + b)$ можно сверху оценить, как $\log n$.}
    
    \item[] {Суммарный размер динамик в данном случае может достигать \complexity$(n^2)$, поэтому для пересчёта, надо эффективно переиспользовать уже посчитанные динамики и избегать их копирования. Если они хранятся в stl контейнерах, таких как std::vector или std::set, то std::swap от двух таких контейнеров работает за \complexity$(1)$. Это удобно использовать для слияния динамик. }
}

\details[mode=main; summary=Задачи] {
    \item[] {\link[href=https://codeforces.com/contest/1709/problem/E]{Codeforces 1709-E}}
    \item[] {\link[href=https://codeforces.com/contest/1923/problem/E]{Codeforces 1923-E}}
    \item[] {\link[href=https://codeforces.com/contest/1606/problem/F]{Codeforces 1606-F}}
    \item[] {\link[href=https://atcoder.jp/contests/arc162/tasks/arc162_c]{Atcoder ARC162-C}}
}

\center[] {<h2>Переливания по глубинам</h2>}

\details[mode=main; summary=Введение] {
    Рассмотрим такую модель:
    
    \itemize[] {
        \item[] {
            Пусть $s_1 \ge \ldots \ge s_m$~--- размеры динамик детей текущей вершины. Тогда размер динамики текущей вершины равен $s_1 + 1$, а слияние происходит за \complexity$(s_2 + \ldots + s_m)$.
        }
    }
    
    Таким образом, размер динамики в вершине $v$ равен \complexity$(d_v)$, где $d_v$~--- расстояние от вершины $v$ до самого глубокого листа в её поддереве.
}

\details[mode=main; summary=Время работы] {
    Пусть каждому элементу динамики в вершине $v$ сопоставляется какая-то вершина из поддерева вершины $v$. Тогда одному из элементов динамики размера $s_1 + 1$ сопоставим вершину $v$, а всем остальным~--- те же вершины, что динамике соответствующего ребёнка.
    
    Тогда \complexity$(s_2 + \ldots + s_m)$ можно воспринимать, как перебор вершин, соспоставленных динамикам всех остальных детей. Таким образом, после перебора таких вершин они больше не будут сопоставлены ни одному значению динамики, поэтому каждая вершина будет перебрана не более одного раза, поэтому данный алгоритм работает за \complexity$(n)$.
}

\details[mode=main; summary=Замечание] {
    Суммарный размер динамики в данном случае может достигать \complexity$(n^2)$, как и в случае с переливаниями по размерам, поэтому std::swap вам в помощь.
}

\details[mode=main; summary=Задачи] {
    \item[] {\link[href=https://codeforces.com/contest/1249/problem/F]{Codeforces 1249-F}}
    \item[] {Всероссийская олимпиада имени Келдыша. 2024, задача F.}
}

