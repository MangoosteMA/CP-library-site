\title[]{Комбинаторика на деревьях}

\center[]{<h2>Код Прюфера</h2>}

\details[mode=main; summary=Теория] {
    Код Прюфера для дерева из $n \ge 2$ вершин, пронумерованных от $1$ до $n$~--- это последовательность из $n-2$ чисел от $1$ до $n$, однозначно кодирующее это дерево.
    
    Более того, каждая последовательность из $n-2$ чисел от $1$ до $n$ является кодом Прюфера для какого-то дерева на $n$ вершинах. Таким образом, коды Прюфера это биекция между пронумерованными деревьями и такими последовательностями.
}

\details[mode=main; summary=Построение кода Прюфера] {
    Код прюфера строится следующим образом:
    
    \itemize[] {
        \item[] {
            Инициализируем код прюфера пустым массивом.
        }
        \item[] {
            Пока в графе осталось хотя бы 3 вершины, выбираем лист с минимальным номером и в конец кода Прюфера добавляем номер вершины, с которой он связен. После этого удаляем вершину $v$ из дерева.
        }
    }
    
    Построенный код действительно имеет размер $n-2$ и состоит только из чисел от $1$ до $n$.
    
    Существует более простой для понимания алгоритм построения кода Прюфера за \complexity$(n\log n)$, но ниже приведён алгоритм за \complexity$(n)$.
    
    Для начала заметим, что вершина $n$ никогда не будет удалена, так как при $n \ge 2$ в дереве есть хотя бы два листа, а значит вершина $n$ не может быть минимальным листом. Давайте подвесим дерево за вершину $n$. Тогда верно следующее замечание: если вершина $v$ будет удалена, то она будет удалена позже всех вершин в её поддереве.
    
    \details[summary=Доказательство] {
        Если вершина $v$ удалена до того, как удалены все вершины в её поддереве, это означает, что все вершины в её \<<наддереве\>> должны быть удалены. А значит вершина $n-1$ должна быть удалена, чего не может быть.\qed
    }
    
    По ходу алгоритма будем поддерживать две переменные $a$ и $b$ и такой инвариант: все листья дерева, кроме возможно вершины $b$, имеют номера $\ge a$. Если $b=-1$, то все листья имеют номера $\ge a$. Изначально $a = 1$ и $b=-1$.
    
    Тогда если $b \neq -1$ и $b < a$, то $b$~--- это минимальный лист. Иначе, будем увеличивать $a$, пока вершина $a$ не является листом. Таким образом, мы нашли минимальный лист. Теперь удалим его из дерева. Пусть предок этого листа~--- вершина $p$. Тогда эта вершина и только она могла стать новым листом. Если вершина $p$ теперь лист, то если $p < a$, то присвоим $b=p$, иначе присвоим $b=-1$. Нетрудно видеть, что в обоих случаях инвариант выполнен.
    
    Чтобы проверять, является ли вершина листом, достаточно поддерживать её степень. Таким образом, данный алгоритм можно реализовать за \complexity$(n)$.
}

\details[mode=main; summary=Реализация] {
\code[language=C++] {
// Returns prufer code (0-indexed)
std::vector<int> buildPruferCode(const std::vector<std::pair<int, int>> &edges) {
    int vertices = edges.size() + 1;
    if (vertices == 1) {
        return {};
    }

    std::vector<std::vector<int>> g(vertices);
    for (const auto &[v, u] : edges) {
        g[v].push_back(u);
        g[u].push_back(v);
    }
    std::vector<int> parent(vertices), degree(vertices);

    std::function<void(int)> dfs = [&](int v) -> void {
        degree[v] = g[v].size();
        for (auto u : g[v]) {
            g[u].erase(std::find(g[u].begin(), g[u].end(), v));
            parent[u] = v;
            dfs(u);
        }
    };
    dfs(vertices - 1);

    std::vector<int> prufer(vertices - 2);
    int pointer = 0, option = -1;

    for (int i = 0; i < vertices - 2; i++) {
        if (option == -1) {
            while (degree[pointer] > 0) {
                pointer++;
            }
            option = pointer++;
        }
        prufer[i] = parent[option];
        option = -1;
        if (--degree[prufer[i]] == 0 && prufer[i] < pointer) {
            option = prufer[i];
        }
    }
    return prufer;
}
}
}

\details[mode=main; summary=Восстановление дерева по коду Прюфера] {
    Ниже представлен алгоритм, однозначно восстанавливающий дерево по коду Прюфера. Из этого алгоритма, собственно, следует биективность, упомянутая в самом начале, так как он будет работать для произвольной последовательности длины $n-2$ из чисел от $1$ до $n$.
    
    Если $n=2$, то дерево восстанавливается однозначно.

    Если $n > 2$, то заметим, что минимальное значение, которое не встречается в коде Прюфера~--- номер первого удалённого алгоритмом листа. Так как длина кода Прюфера $n-2$ \implies такое значение найдётся. Тогда добавим ребро из этого листа в первый элемент кода Прюфера, удалим этот лист из списка вершин и удалим первое значение кода. Таким образом, мы свели восстановление кода Прюфера для дерева размера $n$ к дереву размера $n-1$.
    
    Чтобы реализовать это за \complexity$(n)$ будем, аналогично построению кода Прюфера, поддерживать две переменные $a$ и $b$ изначально равные $a=1$ и $b=-1$. Они будут означать, что номер минимального значения, которое не встречается в коде Прюфера либо равно $b$, либо $\ge a$.
    
    Тогда, чтобы найти минимальное значение, которое не встречается в коде, надо либо выбрать $b$, если $b < a$ и $b \neq -1$, либо увеличивать $a$ до тех пор, пока значение $a$ встречается в коде. Таким образом мы восстанавливаем очередное ребро, удаляем одну вершину и переходим к следующему значению кода. После этого, если другой конец этого ребра больше не встречается в коде и его номер $< a$, надо присвоить его значение в $b$, иначе надо присвоить $b = -1$. Нетрудно видеть, что значения $a$ и $b$ корректно пересчитываются.
    
    Чтобы проверять, является ли очередное значение кода Прюфера последним, достаточно для каждого значения поддерживать количество таких элементов в коде. Таким образом, данный алгоритм можно реализовать за \complexity$(n)$.
}

\details[mode=main; summary=Реализация] {
\code[language=C++] {
// Returns list of edges of the decoded tree (0-indexed)
std::vector<std::pair<int, int>> decodePruferCode(const std::vector<int> &prufer) {
    int vertices = prufer.size() + 2;
    std::vector<int> count(vertices);
    for (auto vertex : prufer) {
        count[vertex]++;
    }

    std::vector<std::pair<int, int>> edges;
    edges.reserve(vertices - 1);
    int pointer = 0, option = -1;

    for (auto vertex : prufer) {
        if (option == -1) {
            while (count[pointer] > 0) {
                pointer++;
            }
            option = pointer++;
        }
        edges.emplace_back(vertex, option);
        option = -1;
        if (--count[vertex] == 0 && vertex < pointer) {
            option = vertex;
        }
    }

    if (vertices == 2 || prufer.back() == vertices - 1) {
        while (count[pointer] > 0) {
            pointer++;
        }
        edges.emplace_back(pointer, vertices - 1);
    } else {
        edges.emplace_back(prufer.back(), vertices - 1);
    }
    return edges;
}
}
}

\details[mode=main; summary=Cвойство] {
    В коде Прюфера, вершина $v$ встречается $d_v - 1$ раз, где $d_v$~--- степень вершины $v$.
    
    \details[summary=Доказательство] {
        Докажем это по индукции. База: $n = 2$.
        
        Если $n \ge 3$, то заметим, что первый удалённый алгоритмом лист не встречается ни разу, а вершина $v$, с которой он соединён, по индукции встретится $d_v - 2$ раза. Но так как эта вершина добавлена в код Прюфера на этой итерации \implies она встретится $d_v - 2 + 1 = d_v - 1$ раз. У всех остальных вершин степень после удаления листа не изменилась, поэтому для них индуктивный переход верен.\qed
    }
    
    Это свойство помогает решать некоторые комбинаторные задачи, в которых есть ограничения на степени вершин.
}

\center[]{<h2>Основные формулы</h2>}

\details[mode=main; summary=Количество пронумерованных деревьев] {
    Количество пронумерованных деревьев на $n$ вершинах равно $n^{n-2}$.
    
    \details[summary=Доказательство] {
        Это очевидное следствие биективности пронумерованных деревьев и последовательностей длины $n-2$ из чисел от $1$ до $n$. Сама биекция строится через коды Прюфера.
    }
}

\details[mode=main; summary=Количество дополнений леса до дерева] {
    Пусть дан пронумерованный лес на $n$ вершинах и $s_1$, $\ldots$, $s_k$~--- размеры компонент связности. Тогда количество способов добавить в этот лес $k - 1$ ребро так, чтобы он стал деревом, равно:
    $$
    n^{k-2} \cdot \prod\limits_{i=1}^k s_i
    $$
    \details[summary=Доказательство] {
        Для $k=1$ эта формула верна, поэтому далее будем полагать, что $k \ge 2$.

        Рассмотрим такой алгоритм: в каждой компоненте связности выберем ровно одну \<<особую\>> вершину и дополним лес до дерева следующим образом:
        
        \itemize[] {
            \item[] {
                Если осталось $k \ge 3$ компонент связности, то выберем любую вершину леса (в том числе можем выбрать и \<<особую\>> вершину) и добавим ребро из неё в \<<особую\>> вершину $v$, ещё не связную с данной вершиной. После этого, вершину $v$ более не будем считать \<<особой\>>. Заметим, что этот шаг сохраняет следующий инвариант: каждая компонента связности содержит ровно одну \<<особую\>> вершину.
            }
            \item[] {
                Если осталось только две компоненты связности, то добавим ребро между оставшимися двумя \<<особыми\>> вершинами и закончим алгоритм. Заметим, что их действительно осталось ровно две (это следует из инварианта выше).
            }
        }
        
        Количество способов дополнить лес до дерева таким образом равно:
        $$
        \prod\limits_{v=1}^k s_v \cdot \prod\limits_{m=1}^{k - 2} n(k - m)=
        (k - 1)! \cdot n^{k-2} \prod\limits_{v=1}^k s_v
        $$
        Заметим, что эта величина в $(k-1)!$ раз больше чем та, которую мы хотим получить. Поэтому нам достаточно показать, что каждое дополнение дерева до леса мы учли ровно $(k-1)$! раз.
        
        Действительно, рассмотрим какое-то множество рёбер, дополняющее данный лес до дерева. Также зафиксируем порядок этих рёбер (всего есть $(k-1)!$ порядков). Достаточно доказать, что существует ровно один способ применить описанный выше алгоритм, чтобы он добавил в лес рёбра ровно в таком порядке.
        
        При фиксированном порядке добавления рёбер заметим, что однозначно восстанавливается множество \<<особых\>> вершин, выбранных в начале алгоритма, при котором такой порядок добавления рёбер возможен.
        
        \details[summary=Доказательство] {
            Последнее ребро обязано соединять две \<<особые\>> вершины. Все остальные рёбра обязаны соединять произвольно выбранную вершину и \<<особую\>> вершину.
            
            Сожмём все исходные компоненты связности в одну вершину. Получим дерево на $k$ вершинах. Подвесим это дерево, за один из конецов последнего ребра в данном порядке. Рассмотрим все рёбра, кроме последнего, в порядке возрастание расстояние до корня от верхнего его конца (то есть сверху вних). Так как каждая компонента должна содержать ровно одну \<<особую\>> вершину, при рассмотрении очередного ребра, более верхняя компонента уже однозначно содержит \<<особую\>> вершину (по построению), поэтому \<<особая\>> вершина в более нижней компоненте определяется однозначно (это нижний конец этого ребра).\qed
        }
        
        Таким образом, такой алгоритм действительно учитывает каждое возможное дополнение леса до дерева ровно $(k-1)!$ раз, что завершает доказательство.\qed
    }
}

\details[mode=main; summary=Количество лесов] {
    Количество пронумерованных лесов на $n$ вершинах и $m$ компонентах связности, в которых вершины $1$, $\ldots$, $m$ лежат в разных компонентах связности, равно $mn^{n - m - 1}$.
    
    \details[summary=Доказательство] {
        Это нетрудное следствие формулы дополнений леса до дерева. Давайте рассмотрим лес, в котором есть $m-1$ ребро: $(1, 2)$, $\ldots$, $(m - 1, m)$. То есть соединим вершины $1$, $\ldots$, $m$ в бамбук. Тогда искомое количество лесов равно количеству способов дополнить этот лес до дерева.
        
        Тогда размер одной компоненты связности равен $m$, а всех остальных равен $1$. Используя формулу выше, получаем, что искомая величина равна $mn^{(n - m + 1) - 2} = mn^{n - m - 1}$.\qed
    }
}

\details[mode=main; summary=Количество деревьев с заданными степенями] {
    Количество деревьев на $n \ge 2$ вершинах, в которых вершина $v$ имеет степень $d_v$, равно:
    $$
    \frac{(n - 2)!}{\prod\limits_{v=1}^n (d_v - 1)!}
    $$
    Само собой эта формула предполагает, что хотя бы одно такое дерево существует. То есть эта формула работает, если:

    \itemize[] {
        \item[] {$d_v > 0$ для всех $1 \le v \le n$.}
        \item[] {$\sum\limits_{v=1}^n d_v = 2(n - 1)$}
    }

    \details[summary=Доказательство] {
        Мы знаем, что в коде Прюфера вершина $v$ встречается $d_v - 1$ раз. Поэтому искомая величина равна количеству кодов Прюфера, в которых вершина $v$ встречается $d_v - 1$ раз. А это уже известная комбинаторная формула:
        $$
        {n - 2 \choose d_1, \ldots, d_n} = \frac{(n - 2)!}{\prod\limits_{v=1}^n (d_v - 1)!}
        $$
        Также, отсюда легко следует, что условия, когда данная формула работает, являются критерием существования дерева с задаными степенями (само собой, если $n \ge 2$).\qed
    }
}

\center[]{<h2>Приложения</h2>}

\details[mode=main; summary=Задачи] {
    \item[] {\link[href=https://atcoder.jp/contests/arc106/tasks/arc106_f]{Atcoder ARC106-F}}
    \item[] {\link[href=https://codeforces.com/contest/1267/problem/F]{ICPC 2019–2020, NERC. Задача F}}
}
